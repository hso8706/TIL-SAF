# **객체 지향 프로그래밍**
### Index
- 객체 지향 프로그래밍이란?
- OOP 기초
  - Class와 Instance
- OOP 문법
  - OOP 변수
  - 데코레이터
  - OOP 메서드

## 객체 지향 프로그래밍
### 절차 지향 프로그래밍
- 특징 및 장점
```
: 코드 순서대로 프로그램이 실행됨.
: 기능 중심의 프로그램
: 순서가 정해져 있기 때문에 실행이 빠름
```
- 단점
```
: 대형 프로그램에는 적합하지 않음.
```
### 객체 지향 프로그래밍
```
- 특징 및 장점
: 잘 만들어 놓은 객체는 재사용하기 매우 용이
: 객체 자체로 데이터와 행동(실행)이 독립적으로 정의됨
: 객체만을 조립하면서 프로그래밍 가능
: 개발 용이성, 유지 보수 편의성, 신뢰성을 바탕으로 생산성 대폭 증가 => 대형 프로그래밍에 적합
```
- 단점
```
: 여러 모듈을 불러와야하기 때문에 절차 지향 프로그래밍에 비해 속도가 느릴 수 있음.
: 각각의 객체(모듈)를 만드는데 시간과 노력이 많이 필요하고, 이를 하나의 프로그램으로 만드는데에도 상호 작용 구조 따위 등 신경쓸 것이 많음.
```

## OOP 기초
### 객체
- 의미
```
: 객체란, 클래스에서 정의한 것을 토대로 메모리에 할당된 것
: 속성(변수)와 행동(함수-메서드)으로 구성된 모든 것을 객체라고 한다.
```
- 클래스와 객체
```
클래스 : 설계도 => 모듈
객체 : 실제 사례 => 인스턴스

- 자료형 => 사실 클래스
: 우리가 만든 변수에 값을 할당하면, 해당 변수는 해당 값이 속하는 클래스의 객체가 된다.
```

## OOP 문법
### 기본 문법
- 클래스 정의 
```
- `class` 키워드
class MyClass:
```
- 인스턴스 생성
```
- `<클래스명>()`
my_instance = MyClass():
```
- 메서드 호출
```
- `<객체명 or 클래스명>.<메서드명>()`
my_instance.my_method()
```
- 속성 접근
```
- `<객체명 or 클래스명>.<변수명>`
my_instance.my_attribute
```
### 객체 비교하기
- `==`  
```
: `값`만을 비교하는 연산자  
: 변수가 참조하는 객체가 동등한(내용이 같은) 경우 True
```
- `is`
```
: 객체가 참조하는 `주소`자체를 비교하는 연산자
: 변수들이 동일한 객체를 가리키는 경우 True
```

### 클래스와 인스턴스 간의 namespace(주소)
- 클래스와 인스턴스는 각자 따로 namespace를 생성(주소를 따로 할당받음)
- 인스턴스에서 특정 속성에 접근하면, 인스턴스 -> 클래스 순으로 탐색

### 클래스 기본 구조
```python
Class Person: # 파이썬에서도 클래스명은 첫 문자를 대문자로 쓰는 듯 함.
    name = 'unknown' # 자바와 다르게 클래스 변수와 인스턴스 변수의 큰 구분이 없는듯함

    def __init__(self, name): # 생성자(__init__)
        self.name = name      # self 인자는 파이썬에서 인스턴스 호출 시 자동으로 제공함

    def person_method(args):
        <method_body>
```

### 속성
- 클래스 변수
```
: class 내부에 `변수명 = 값`의 형태로 존재
: 클래스 변수에 접근하는 방법은 `<클래스명>.<클래스 변수>`이다.
: 인스턴스 생성 후 <인스턴스명>.<클래스 변수>에 접근하여 값을 수정하면 인스턴스 변수가 되어버림...(?편한건가)
```
- 인스턴스 변수
```
: 변수명만 존재하는 빈 변수가 존재하고, 생성자를 통해 값을 채워주는 변수
: 즉, 인스턴스 생성 시에만 값이 할당되는 변수이다.
: 클래스 구조에 따로 변수명을 설정하지 않고 생성자 내에서만 작성해도 변수 공간이 생기는 것 같음
```

## OOP 메서드
### 메서드 종류
- 인스턴스 메서드
- 클래스 메서드
- 정적 메서드

### 인스턴스 메서드
- 의미
```
: 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드
: 메서드 호출 시, 첫번째 인자로 `self`가 자동으로 전달됨
: 인스턴스 메서드는 클래스 변수와 인스턴스 변수 모두 사용 가능.
```
- 구조
```python
class MyClass:
    def instance_method(self, arg1, arg2, ...):

# 호출
my_instance = MyClass()
my_instance.instance_method(...)
```

### 매직 메서드
- 의미
```
: Double underscore(`__`)가 있는 메서드
: 특수한 동작을 위해 만들어진 메서드(특정 상황에 자동으로 호출되는 메서드)
: 스페셜 메서드, 매직 메서드라고 부름
```
- 종류 예시
```
__str__(self):
: 이 객체를 문자열로 표현하면 어떻게 표현할지를 지정
: print 함수 등에서 객체를 출력하면 자동으로 호출되는 메서드
__gt__(self, other):
: 부등호 연산자(>, greater than)
```
- 사용 예시
```
class Circle:
    def __init_(self, r):
        self.r = r
    
    def area(self):
        return 3.14 * self.r * self.r
    
    def __str__(self):
        retrun f'[원] radius: {self.r}'

    def __gt__(self, other):
        return self.r > other.r

c1 = Circle(10)
c2 = Circle(1)

print(c1) # [원] radius: 10
print(c2) # [원] radius: 1
print(c1 > c2) # True
print(c1 < c2) # False
```

### 생성자 메서드
- 의미
```
: 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드
: 인스턴스 변수들의 초기값을 설정
: `__init__` 메서드 자동 호출
```

### 클래스 메서드
- 의미
```
: 클래스가 사용할 메서드
: `@classmethod`라는 `데코레이터`를 사용하여 정의(java의 애너테이션 같은 느낌인가보다)
: 호출 시, 첫번째 인자로 클래스(cls)가 전달된
: 클래스 메서드는 클래스 변수만 사용 가능, 인스턴스 변수는 사용 불가능
```
- 구조
```python
class Myclass:

    @classmethod
    def class_method(cls, arg1, ...):

# 호출
MyClass.class_method(...)
```

### 데코레이터
- 의미
```
: 자바의 애너테이션과 비슷해보임
: 함수를 어떤 함수로 꾸며서 새로운 기능을 부여
: @데코레이터(함수명) 형태로 함수 위에 작성
: 순서 중요
```
- 구조(만드는 법)
```python
def emoji_decorator(func): # func 매개변수 자리에는 데코레이터의 피대상자인 함수가 인자로 제공된다.
    def wrapper(name): # wrapper의 매개변수에 `(**args, **kwargs)`를 넣으면 더 일반적으로 사용할 수 있는 데코레이터가 된다.
        func(name)
        print("^~^//")
    return wrapper

@emoji_decorator
def ko_hello(name):
    print(f'안녕하세요, {name}님!')

# 호출
ko_hello('홍길동')
# 안녕하세요, 홍길동님!
# ^~^//
```

### 스태틱 메서드
- 의미
```
: 인스턴스 변수, 클래스 변수를 전혀 다루지 않는 메서드 => 객체 혹은 클래스 상태를 수정할 수 없음.
: 속성(변수)을 다루지 않고 기능(행동)만을 하는 메서드를 정의할 때 사용
: 클래스의 namespace에 귀속됨.
```
- @staticmethod
```
: 해당 데코레이터를 사용하여 스태틱 메서드임을 정의
``` 