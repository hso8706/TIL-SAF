# 23.02.16
## APS 으용
### Index
1. 비트 연산
2. 순열 응용 - 비트 마스킹 순열
   - 원소 선택 관리
3. 순열 응용 - Next Permutation
   - 다음 순열 => 규칙(순서)가 있다는 의미
   - 재귀 사용 안함, 중복체크 안함 => 속도가 빠름
4. 조합 응용 - Next Permutation 활용

## 비트 연산
### & 연산과 << 연산
- flag 역할을 하는 연산

## 순열 응용 - 비트 마스킹 순열
### 순열
- 정의
  - 서로 다른 것들 중의 몇 개를 뽑아서 한 줄로 나열하는 것.
  - 순서의 의미가 있음. => 같은 요소를 뽑더라도 다른 경우의 수 일 수도 있음
- 팩토리얼
  - 10! : 괜찮은 정도
  - 11! : 힘들다, 순열말고 다른 것으로 풀 생각을 하자
- 구현법
  - 반복문을 이용한 순열 생성
    - 뽑는 수가 고정적일 때 사용 가능(가변적인 경우에는 반복문을 추가 생성하기 힘듬)
  - 재귀 함수를 이용한 순열 생성
    - 뽑는 개수가 가변적일 때도 사용 가능(얼마나 확인하고 재귀에서 복귀할 지 정할 수 있기 때문)
  - 비트 마스킹을 통한 순열 생성
### 비트 마스킹을 통한 순열 생성
- 변경점
  - `boolean[] isSelected` => **int 비트 마스킹**
- int 비트 마스킹
  - 32 bit, 32자리까지 확인할 수 있음
  - 순열은 어차피 11! 이상이면 거의 불가능하다고 볼 수 있으니 int형 비트면 충분히 모든 것을 확인할 수 있다.
- 사용법
  - 인자 : cnt => cnt, flag(비트 마스킹)
  - flag 자체는 변경되어서 재귀로 넘어가지 않기 때문에 사용 해제와 같은 코드가 필요 없다.

## 순열 응용 - Next Perputation
### Next Perputation
- 현 순열에서 사전 순으로 다음 순열 생성
- 최대 6자리까지의 수 가능 (n <= 6)
- 예시
  - 156이 주어졌을 때, 구성은 같고 해당 수보다 큰 수 중에 가장 작은 수는?
- 예시 풀이
  - 1, 5, 6으로 모든 순열 경우의 수를 구함
  - 해당 순열 경우의 수를 사전순으로 정렬
### Next Perputation의 알고리즘
- 배열을 오름차순으로 정렬하는 전처리가 필요함.
  - 첫 생성 순열은 가장 작은 순열 형태에서 출발
- 반복문
  - 뒤쪽부터 탐색하며 교환위치(i-1)찾기 (i: 꼭대기)
  - 뒤쪽부터 탐색하며 교환위치(i-1) 와 교환할 큰 값 위치(j) 찾기
  - 두 위치 값(i-1, j) 교환
  - 꼭대기 위치(i)부터 맨 뒤까지 오름차순 정렬
- 주의사항
  - 첫 한 번의 실행이 무조건 먼저 일어나야함 => do ~ while 사용