# 23.02.13
### Index
1. 리스트
2. 단순 연결 리스트
3. 단순 연결 리스트 - 삽입 연산
4. 단순 연결 리스트 - 삭제 연산
5. 단순 연결 리스트 응용 - 스택 구현
6. 이중 연결 리스트
7. 이중 연결 리스트 - 삽입 연산
8. 이중 연결 리스트 - 삭제 연산

## List
### list
- 의미 및 특징
  - 순서를 가진 데이터의 집합을 가리키는 추상자료형
  - 데이터 중복 허용
- 구현 방법에 따른 분류
  - 순차 리스트, ArrayList
    - 배열을 기반으로 구현된 리스트
  - 연결 리스트, LinkedList
    - 메모리의 동적할당을 기반으로 구현된 리스트
### 순차 리스트, ArrayList
- 의미 및 특징
  - 1차원 배열에 항목들을 순서대로 저장
  - 배열의 인덱스를 이용해 데이터 접근 가능
- 삽입 연산
  - 데이터 삽입 시, 삽입되는 인덱스 이후의 데이터가 한 칸씩 밀리는 방식
- 삭제 연산
  - 데이터 삭제 시, 삭제되는 인덱스 이후의 데이터가 한 칸씩 땡겨지는 방식
- 단점
  - 데이터 삽입, 삭제 시 메모리 배열을 위해 리소스가 많이 소모됨.
### 연결 리스트, LinkedList
- 의미 및 특징
  - 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 각 원소가 하나의 전체적인 자료구조를 이룸.
  - 자료구조 크기를 동적으로 조절할 수 있음(메모리를 효율적으로 사용할 수 있음)
- 노드, Node
  - LinkedList에서 하나의 원소를 표현하는 키워드
  - `데이터 필드`와 `링크 필드`로 구성되어 있음
    - 데이터 필드 : 값을 저장
    - 링크 필드 : 다음 노드의 참조값을 저장
- 헤드, Head
  - 연결 리스트의 첫 노드에 대한 참조값을 갖고 있음
  - 가장 첫 노드의 주소를 의미하는 듯함.
- 연결 리스트의 종류
  - 단순 연결 리스트
  - 이중 연결 리스트
  - 원형 연결 리스트

## Linked List
### 연결 리스트의 종류
- 단순 연결 리스트(단방향)
- 이중 연결 리스트(양방향)
- 원형 연결 리스트
### 단순 연결 리스트
- 연결 구조
  - 헤드 : 첫 노드의 주소값을 참조
  - 노드 : 다음 노드의 링크 필드에 주소값을 저장
  - 마지막 노드 : 링크 필드에 null

## 단순 연결 리스트 - 삽입 연산
### 공백 리스트의 첫번째에 노드 삽입(노드 값 : 'A')
1. 새로운 노드 new 생성
2. 새로운 노드 new의 데이터 필드에 'A' 할당
3. Head에 저장된 참조값을 new 노드의 링크 필드에 할당(값: null)
4. Head에 new 노드의 주소값(참조값)을 할당
### 추가 삽입 - 첫번째에 노드 삽입(노드 값 : 'C')
1. 새로운 노드 new 생성
2. 새로운 노드 new의 데이터 필드에 'C' 할당
3. Head에 저장된 참조값을 new 노드의 링크 필드에 할당(값: A 노드의 참조값)
4. Head에 new 노드의 주소값(참조값)을 할당
### 삽입 과정의 일반화_처음 삽입
1. 노드 생성
2. 생성된 노드의 데이터 필드 채우기
3. 생성된 노드의 링크 필드 채우기 : 이전 노드 혹은 Head의 참조값을 new 노드의 링크 필드에 할당
4. 이전 노드 혹은 Head의 링크 필드 수정
### 삽입 과정의 일반화_마지막 삽입
1. 새로운 노드 new 생성
2. 새로운 노드 new의 데이터 필드에 'D' 할당
3. new 노드 링크 필드에 null 저장
4. 이전 노드(기존 tail 노드) 링크 필드에 new 노드의 참조값 할당(원래는 null)
### 삽입 과정의 일반화_중간 삽입
1. 새로운 노드 생성
2. new 노드 데이터 필드 할당
3. 삽입 위치의 이전 노드의 링크 필드 복사 및 새 노드 링크 필드에 할당
4. 이전 노드의 링크 필드에 new 노드 참조값 할당