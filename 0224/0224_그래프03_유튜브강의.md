# 23.02.24

### Index
1. 그래프 탐색 - 깊이 우선 탐색(DFS)
2. DFS 구현 - 인접 행렬
3. DFS 구현 - 인접 리스트
4. Flood Fill 알고리즘

### Index 팁
1. 그래프 탐색 - 깊이 우선 탐색(DFS)
2. DFS 구현 - 인접 행렬
- 정점의 개수가 10000개 정도 된다 => 인접 행렬로 구현하기 어렵다.
3. DFS 구현 - 인접 리스트
4. Flood Fill 알고리즘

### DFS
- 시작 정점에서 하나의 길만 선택, 더 이상 못 갈때까지 탐색 후 마지막 갈림길에서 재선택하는 순회방법
- DFS 알고리즘에서 사용하는 방문 체크는 방문 후 체크하고, 이를 되돌리면 안된다. (그럴 필요도 없고)
- 한 번 모두 탐색하면 끝.

### DFS 구현
- 탐색 가능 처리
  - Stack 자료 구조 사용
  - 재귀 호출 사용
- 방문 처리 시점
  - 탐색 시 방문 처리, 사실 DFS의 경우는 방문 체크 순서가 큰 의미가 없음
  - BFS는 큐에 집어넣는 시점에서 처리(== 방문 전, 미리 찜꽁)

### DFS 구현 - 인접 행렬
- DFS_AdjMatrixTest.java 참고

### DFS 구현 - 인접 리스트
- DFS_AdjListTest.java 참고
- DFS_AdjListTest02.java 참고

### Flood fill
- flood fill 혹은 seed fill
- 다차원 배열의 어떤 칸과 연결된 영역을 찾는 알고리즘
- 주어진 시작점으로부터 연결된 영역을 찾는 알고리즘
- 4방향, 8방향, DFS, BFS
 
### Flood fill 예시 문제; 섬과 바다
- 예시 문제 제시
  - 섬과 바다 지도가 주어졌을때, 섬의 개수를 세는 프로그램 만들기
- 예시 문제 해결
  - 연결된 땅의 덩어리 == 섬
  - 정점 : 한 방의 땅, 간선 : 땅과의 연결
  - 땅 방문 여부
    - boolean 으로 처리 가능
    - 혹은 2이상의 숫자로 가능 => 같은 섬을 같은 숫자로 매김으로써 섬의 개수와 섬의 크기도 알 수 있음

### 추가 슬라이드(그래프 최단 경로 탐색)
- 주의사항
  - 가중치가 존재하는지
    - 존재한다면 양의 가중치인지 => 다익스트라
  - 가중치가 없는지
    - BFS, 아묻따
  
- 결론
  - 그래프 + 가중치가 없음 + 최단 경로를 구해라
    - => 무적권 BFS
- 결론의 이유
  - DFS가 아닌 이유
    - 총정점수 = N * M => 최악의 시나리오 == 장애물이 없는 경우 => 시간복잡도 고려 + 메모리 낭비가 심함