# 23.02.07
### Index
1. 입/출력 처리
   - A형 대비 
     - 입/출력의 최적화! 필요
     - 30% 이상 속도 개선 가능
2. SW 문제 해결
3. 알고리즘 성능
   - 시간 복잡도 : 수행 시간(속도)
     - Big-O 표기법, O( )
   - 공간 복잡도 : 메모리 사용량
     - Stack + Heap + Class  
    // 시간을 줄이는게 생각보다 정말 힘들다. 기존 코드를 뒤집어 엎어야할 때도 있기 때문...  
    // 따라서 코드를 짜고나서 고치는게 아니라 문제 조건에서 따질 수 있는 부분을 확실히 확인하고 코드짜기를 시작하는 연습할 것.
4. 재귀 호출
5. 재귀 호출 - 피보나치 수열
6. 재귀 호출 응용 - 하노이탑

### 입/출력 처리
- 표준 입출력
  - System.in : 입력데이터 읽기
  - System.out : 결과데이터 출력
  - System.err : 에러 출력 스트림(별로 안씀)
- 표준 입출력 대상 변경
  - System.setOut()
  - System.setErr()
  - System.setIn()
    - System.setIn(new FileInputStream("tc.txt"))

- java.util.Scanner
  - 특징
    - 파일 스트림, 입력 스트림 등과 같은 다양한 입력 소스를 생성자 인자로 제공받는다.
    - 구분자를 기준으로 토큰을 구분하여 입력받음
    - 편하지만 느린 친구...
  - 주요 메서드
    - nextInt()
    - nextDouble()
    - next()  
    - nextLine()
  - nextInt(), nextDouble(), next()의 특징  
    : White space문자를 만나면 처리된다. 즉, 처리된 후 다음 입력은 white space문자부터 시작됨.  
    : 시작점의 white space 문자는 알아서 제거된다.  
  - nextLine()의 특징  
    : 한 라인을 통째로 입력받기 때문에 위의 메서드들과는 구분자가 다르다.  
    : 위 메서드들은 White space문자(공백_space, 탭, 개행)를 만나면 처리됨  
    : nextLine은 공백_space, 탭은 포함하여 입력받음, 개행을 만나면 처리  
    : 구분자(개행 문자)까지 포함하여 입력받고, 입력받으면서 개행 문제를 제거한다. 즉, 뒤에 오는 입력에는 구분자가 없다.
- 주의할 점
  - 3개의 메서드와 nextLine()을 혼용하여 사용할 때 구분자를 처리하는 차이가 있으니 주의할 것.

- java.io.BufferedReader
  - 특징
    - 필터 스트림 유형
    - 대량의 데이터 처리 시 수행시간이 효율적임
    - line 단위로 문자열 처리 기능 제공(readLine()메서드)

- java.lang.StringBuilder
  - 특징
    - 문자열 내용 변경 조작 지원
    - append()를 할 때마다, 새로운 배열을 만드는 것임. 즉, 불필요한 메모리 공간이 낭비될 수 있으니 주의!
    - 매번 출력하는 것보다는 한 번에 StringBuilder에 모아서 출력하는게 속도를 단축할 수 있음.(buffer처럼 사용)

## SW 문제 해결
### SW 문제 해결 역량
- 훈련 필요
- 알고리즘을 암기하여 풀어보는 것보다는 원리를 이해하자.
### 문제 해결 과정
1. 문제 읽고 이해
2. 익숙한 용어로 문제를 재정의
3. 어떻게 해결할지 재정의
4. 계획 검증
5. 프로그램 구현
6. 어떻게 풀었는지 재검토 및 개선점 찾기
### 문제 해결 전략
- 주요 체크
  - 단순한 방법으로 시작할 수 있는지
  - 문제를 작은 문제로 분해할 수 있는지
  - 뒤에서부터 생각해서 문제를 풀 수 있는지
  - 정렬해서 문제를 풀 수 있는지(추가)

## 알고리즘 성능
### 무엇이 좋은 알고리즘인가
- 정확성
- **작업량**
- **메모리 사용량**
- 단순성
- 최적성 : 처음부터 고려할 사항은 아님.
### 시간 복잡도, 공간 복잡도
- 시간 복잡도
  - 최선의 경우
    - 빅 오메가 표기법 사용
    - 최선일 경우 최소 이 시간이 걸림
  - 최악의 경우
    - 빅 오 표기법 사용
    - 최악이어도 이 시간보다 덜 걸림.
    - 우리가 말하는 일반적인 시간 복잡도는 빅 오 표기법
  - 평균적인 경우
    - 빅 세타
- 공간 복잡도
### 알고리즘 성능
- java 연산 기준
  - 작업략 기준
    - 1억번의 연산은 1초라고 대충 기준
    - 1초를 넘어서는 알고리즘은 피하기
  - 재귀 호출 횟수
    - 재귀 호출이 몇 번인지를 파악해서 고려
### 빅-오(O) 표기법
- 가장 큰 영향력을 주는 최고 차항만 표시
  - 계수, 상수 제외
### 다양한 시간 복잡도의 비교
- 기억해둘 것
  - 2^n
    - n=10, 1000
    - n=20, 100만
    - n=30, 10억
  - n!
    - n=10, 360만
    - n=11, 4000만
    - n=12, 우우

## 재귀 함수
### 반복(Iteration)과 재귀(Recursion)
- 재귀 의미
  - 자신을 정의하는데 그 내용안에 다시 자신을 포함하는 형태의 함수
- 반복과 재귀
  - 반복과 재귀는 굉장히 유사함.
  - 동일한 작업 형태로 더 작은 문제로 쪼갤 수 있으면 재귀 개념을 사용할 수 있음.
- 재귀 함수 내부 구분
  - 기본 부분(basis part) => 기저 조건
  - 유도 부분(indective part) => 재귀 파생
- 반복문 만들때 고려할 점
  - 반복의 단위를 찾음 : 규칙을 찾는다.
- 재귀 함수 만들때 고려할 점
  - 함수(메서드) 정의를 명확히 할 것
  - 문제를 작은 단위로 쪼개보기. basis part를 찾을때까지 => 기저 조건 확인
  - 함수가 자신의 작업을 수행하기 위해 결정하는 값을 매개변수로 지정
- 재귀 종류
  - 선형 재귀
    - 상황에 따라서 반복문으로 변형 가능
  - 순수 재귀
    - 반복문으로 바꾸기 어려움(거의 불가능)