# 23.02.28

### 그래프에서 최소 비용 문제
- 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
- 두 정점 사이의 비용의 경로 찾기

### 신장 트리
- n개의 정점, n-1개의 간선, 무향 그래프인 트리
- 현 그래프의 모든 정점을 사용하되, 최소한의 간선만을 남긴 그래프(== 사이클이 없음)
- 즉, 신장 트리에선 한 정점에 도달하는 경우가 두 개 이상 존재하지 않는다.

### 최소 신장 트리(MST)
- 가중치가 있는 그래프(트리)에서 사용되는 개념
- 무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리
- MST: Minumum Spanning Tree
  
### 크루스칼(KRUSKAL) 알고리즘
- 간선을 하나씩 선택해서 MST를 찾는 알고리즘

### 크루스칼 알고리즘 해결 순서
1. 모든 간선을 가중치에 따라 오름차순으로 정렬
2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
   - 여기서 사이클이 존재하면, 즉 신장 트리가 아니라면 다음으로 가중치가 낮은 간선을 선택한다.
3. 총 간선의 개수가 n-1개가 될 때까지 반복한다.(접점의 개수 == n)

### 크루스칼 알고리즘 의사 코드
```
MST-KRUSKAL(G, w){
    for 정점 in 정점 집합{
            make-set(점점) //초기화
        }

        간선 집합내의 간선들을 오름차순 정렬(가중치 기준)

        for (가중치가 낮은 간선부터 시작, n-1개가 될때까지 반복)
            if (find-set(접점1) != find-set(접점2)){
                union(접점1, 접점2)
            }
}
```

### PRIM 알고리즘
- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
- MST를 찾기 위한 그리디 패러다임의 알고리즘

### PRIM 알고리즘 해결 순서
1. 임의 정점을 하나 선택해서 시작
2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
3. 모든 정점이 선택될 때 까지 1,2를 반복  
// 마지막 정점을 이을 때에는 마지막 정점과 다른 각각의 정점 사이의 간선의 가중치 중 가장 최소 비용을 선택 => 1,2를 반복하면 자연스레 해결

### PRIM 알고리즘의 핵심
- 서로소인 2개의 집합 정보를 유지해야한다.
1. 트리 정점들 : MST를 만들기 위해 현재까지 선택된 정점들
2. 비트리 정점들 : 선택되지 않은 정점들

### PRIM 알고리즘 의사 코드(미완)
```
//minEdge[]가 PRIM 알고리즘의 핵심
//(minEdge의 idx, value) : idx 정점과 가장 최소 비용을 갖는 간선의 비용
//배열의 초기화는 Integer.MaxValue

MST-PRIM(G, r){ //G: 그래프, r: 시작 정점, minEdge[]: 각 정점기준으로 타 정점과의 최소 간선 비용

    //visited[]: MST에 포함된 정점 여부 파악 배열
    result = 0; //result: mst 비용
    cnt = 0; //cnt: 처리한 정점수
    for 정점번호 in 모든 접점{
        minEdge[정점번호] = Integer.MaxValue
    }
    minEdge[r] = 0 // 시작 정점은 최소 비용을 0으로 할당
    while(true){
        u = minEdge 중 최소 비용을 갖는 정점의 값
        visited[u] = true
        result += minEdge[u]

    }
}
```