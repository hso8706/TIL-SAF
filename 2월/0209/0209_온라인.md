# 23.02.09
## Index
1. 완전 검색 - 부분집합
2. 부분집합 구현 - 반복문
3. 부분집합 구현 - 재귀
4. 완전 검색 - 부분집합의 합
5. 비트 연산
6. 부분집합 응용 - 바이너리 카운팅

## 부분 집합
### 부분집합이란?
- 집합에 포함된 원소들을 선택하는 것
  - 부분 집합을 구하면서 요소의 순서는 중요하지 않다.
  - 즉, `부분 집합`과 `집합`을 굳이 구분할 필요는 없다.
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다.
  - 예시 : 배낭 짐싸기(knapsack)
- 문제에서 어떤 조건이 있는지에 따라 어떤 개념의 문제인지가 달라진다. 하면서 파악하고 카테고리화 해놓자.
  - 집합의 크기가 크면 부분집합으로는 해결할 수 없다.
  
### 부분 집합 문제의 한계
- n
  - n = 10  >>> 2^10 == 1024
  - n = 20  >>> 2^20 == 100만
  - n = 30  >>> 2^30 == 10억 (불가능)
- nCr 중에서 r = n/2이면, 경우의 수가 가장 많음. 항상 확인하고 주의할 것

### 부분 집합 문제 해결 컨셉
- 각 요소에 대응하는 반복문 생성
  - 요소를 선택할 지, 선택하지 않을지를 확인하는 반복문
- 요소의 선택 여부에 대한 확인 배열 생성
  - 요소가 선택됐는제, 선택되지 않았는지 확인하는 배열 필요
  - 요소의 갯수만큼의 길이 필요
- 반복문 혹은 재귀로 해결 가능

### 부분 집합의 합 문제
- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
  - 백트래킹(가지치기) : 정렬이 되었을 땐 되지만, 아닌 경우에는 백트래킹으로는 불가능
  - `NP_완전 문제` 검색해보기 (아직 해결하지 못한 난제)
    - 유형이 뭐가 있는지 눈에만 담아두고, 해당 유형을 나중에 접했을때 이 문제는 효율적인 해결법이 없으니 완전 탐색으로 모두 살펴보자라고 생각할 것

## 비트 연산
### 비트 연산자
- 종류
  - & : AND
  - | : OR
  - ^ : XOR
  - ~ : 모든 비트 반전
  - <<, >> : 쉬프트 연산자
- 꼭 기억할 비트 연산자 : `&`, `|`, `<<`
### `value << n`
- value를 n비트 만큼 왼쪽으로 밀고, 남은 오른쪽 자리는 0으로 채움
- 잘려나갈 비트가 없고, 쉬프트 후에도 부호 비트 영향이 없을때 사용
- 우shift(`>>`)는 빈 왼쪽 자리를 부호 비트로 채움
- 값은 결과적으로 `2^n`이 됨.
- 주로 사용하는 예시 (`1<<n`)
  - isSelect를 대신한다.
  - `1<<n`로 사용하며, 1을 원하는 곳으로 쉬프팅하는데 주로 사용
  - 1을 가져다두고 싶은 곳에 가져다두고 나머진 다 0으로 된 비트
### & 연산자
- 의미
  - value1 & value2
    - value1와 value2이 모두 1일 때만 1비트가 나오고, 다른 경우는 모드 0비트가 나온다.
    - True, False 논리 연산자로 연상해도 좋다.
- 활용, `mask off`
  - `10 & 1 << 3`
    - &연산자는 원하는 비트 자리만 확인하는 방법으로 주로 사용한다.
    - 해당 연산 결과가 `>0` 혹은 `!=0`으로 boolean값을 확인할 수 있다. 
    ```
      0 0 0 0 1 0 1 0
    & 0 0 0 0 1 0 0 0
    -----------------
      0 0 0 0 1 0 0 0
    ```