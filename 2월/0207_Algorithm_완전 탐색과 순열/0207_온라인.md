# 23.02.07
## 하노이탑
### 재귀 호출 조건 리마인드
1. 전체 문제를 작은 부분 문제로 해결할 수 있는지 파악(문제를 flat하게 바라보기)
2. 함수의 역할 명확히 정의하기
  - 이 메서드로 무슨 일을 할 것인지
3. 함수의 결정 요인을 매개변수로 정의
4. 기저 조건 확인
5. 자신이 처리할 내용과 다음 재귀로 넘길 내용 구분하기(잘하기!)
### 재귀 관점에서의 하노이탑 문제 바라보기
- 우리가 아는 정식 하노이탑 문제 풀이(하나씩 풀기)를 잊자
- 큰 덩어리와 작은 덩어리로 나누어 보자(0206_현장 참고)

## 완전 검색(완전 탐색)
### 의미 및 특징
- 모든 시도를 다 해보고 답을 찾는 방법
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 시간이 많이 소요됨
- 하지만 해답을 찾을 확률은 높음
- 대표적인 완전 검색 케이스 : 조합적 문제
### 완전 검샘 관점으로 baby-gin game 문제 바라보기
- 6개의 숫자로 만들 수 있는 모든 숫자 나열하기(중복 포함, 순서가 있기 때문)

## 조합적 문제
### 대표 종류
- 순열
- 조합
- 부분 집합

## 완전 검색 - 순열
### 완전 검색 순열의 시간 복잡도
- O(n!) : 완전 느림;
  - 10! = 360만(안전선)
  - 11! = 4000만(조오금 불안)
  - 12! = 약 5억(안하는게 좋음)
- 따라서 완전 검색 - 순열 문제를 풀 때에는 조건을 보고 시간 복잡도를 미리 예상하고 완전 검색이 가능한지 파악해야한다.
### 순열의 의미와 특징
- 순서의 의미가 있음. 즉, 중복된 조합(구성)을 뽑는것이 허용됨
- nPr로 표현

## 순열 구현 - 반복문
```java
for i from 1 to 3
    for j from 1 to 3
        if j != i then // 이전에 뽑은 수와 같으면 안됨.
            for k from 1 to 3
                if k != i and k != j then
                    print i, j, k
                end if
            end for
        end if
    end for
end for     
```
## 순열 구현 - 재귀
```java
numbers[] : 순열 저장 배열
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열
cnt : 현재까지 뽑은 순열 수의 갯수

perm(cnt)
    if cnt == 3
        순열 생성 완료
    else
        for i from 1 to 3
            if isSelected[i] == true then continue
            numbers[cnt] // i 할당
            isSelected[i] // true 할당
            perm(cnt+1)
            isSelected[i] // false 할당
        end for
```