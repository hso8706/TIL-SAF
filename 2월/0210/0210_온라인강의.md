# 23.02.10
## Index
1. 부분집합 응용 - 바이너리 카운팅
2. 스택
3. 스택 활용 - 계산기
4. 스택 활용 - 브라우저
5. 큐
6. 큐 활용 - 마이쮸


## 부분집합 응용 - 바이너리 카운팅(다시보기)
### & 와 | 비교
- `&` 연산자
  - 내가 보고 싶은 자리의 비트들이 1인지 확인
  - 조건 체크 역할의 개념
- `|` 연산자
  - 내가 처리하고 싶은 자리의 비트를 1로 만듦
  - 이를 bit set이라고함 (덮어 씌움)
### 부분집합과 바이너리 카운팅
- 이진수 조합과 부분집합을 매칭할 수 있음
  - 예를 들면, 3개의 요소를 가진 집합의 부분집합은 0부터 7까지의 십진수 수를 비트마스킹한 수로 변환하고 이를 부분집합과 매칭하면 된다.
- 예시 코드
  ```java
  // 아래 코드를 사용하면 재귀함수를 사용하지 않고 반복문으로 쉽게 부분집합 문제를 해결할 수 있다.

  int arr[] = {3, 6, 7, 1, 5, 4};
  int n = arr.length;

  for(int i = 0; i < (1 << n); i++){ // 부분 집합을 모두 순회하는 반복문
    for(int j = 0; j < n; j++){  // 부분 집합의 일부를 순회하는 반복문
        if( i & (1 << j) != 0)
            System.out.print(arr[j] + " ");
    }
    System.out.println();
  }
  ```

## 스택
### 스택의 특성
- 선형 구조
- 후입선출(LIFO, Last-In-First-Out) : 나중에 들어온 data가 먼저 나감
- `top` : 마지막 data를 의미하는 용어
### 주요 메서드
- push() : 자료 저장
- pop() : top을 반환과 동시에 제거, 자료를 꺼냄
- peek() : top을 반환, 확인용  
- isEmpty() : 스택이 비었는지 확인(bool)
- size() : 스택의 길이(원소의 갯수) 반환
### 스택 응용01; 괄호 검사
- 괄호의 종류 : [], {}, ()
- 문제 해결 컨셉
  - 여는 괄호를 만나면 스택에 넣는다. (push)
  - 닫는 괄호를 만나면 스택에서 괄호를 꺼내고(pop) 쌍이 되는지 비교한다.
- 실패 조건
  - 괄호의 쌍이 맞지 않았을 경우
  - 닫는 괄호가 남았는데 스택이 비었을 경우
  - 닫는 괄호가 끝났는데 스택이 남았을 경우
### 스택 응용02; 함수 호출(function call)
- 함수가 연결되어 호출될 때, stack 구조로 쌓임
- 함수 호출과 동시에 복귀에 관한 정보도 같이 저장된(주소)
- 이를 가장 잘 사용하는 것이 재귀로 구현된 메서드
- Stack을 활용한 반복문 == 재귀 구현 메서드

## 스택 활용 - 계산기
### 중위 표기법과 후위 표기법
- 중위 표기법
  - 연산자를 피연산자의 가운데 표기하는 방법
- 후위 표기법
  - 연산자를 피연산자 뒤에 표기하는 방법
  - 스택에 활용하기 위해서 후위 표기법으로 바꿔서 표현해야한다. (근데 이 부분이 사실 어려움...)
### 구현 단계
1. 중위 표기식을 후위 표기식으로 변환하기
```
// 연산자의 우선순위에 따라 괄호를 사용하여 다시 표현한다.
// 괄호를 기준으로 후위 표기식 변환을 진행한다.
// 괄호를 제거한다.
예 ) A*B-C/D
=> ((A*B)-(C/D))
=> ((AB)*(CD)/)-
=> AB*CD/-
예 ) (6+((5*(2-8))/2))
=> 6528-*2/+
```
2. 후위 표기법의 수식을 스택을 이용하여 계산
   1. 피연산자를 만나면 스택에 push
   2. 연산자를 만나면 필요한 만큼의 피연산자(단항 연산자, 이항 연산자 등)를 스택에서 pop하여 연산
   3. 연산 결과를 다시 스택에 push
   4. 수직이 끝나면 마지막으로 스택을 pop하여 출력(연산 결과)

## 스택 활용 - 브라우저(개인 숙제)

## 큐
### 큐의 특성
- 선형 구조
- 선입선출(FIFO, First In First Out)
- 대기열 개념
- 스택은 개념적인 것이 큰 비중을 가졌지만, 큐는 실제로 알고리즘에서 많이 사용해야하는 자료 구조이다.
- `rear`: 큐의 꼬리부분, 데이터가 삽입되는 부분
- `front`: 큐의 머리부분, 데이터가 나가는 부분
- `enQueue`: 삽입
- `deQueue`: 삭제
### java.util.Queue
- 큐에 필요한 연산을 선언해 놓은 인터페이스
- LinkedList 클래스를 Queue 인터페이스의 구현체로 많이 사용
- 하지만 속도(+시간)를 위해서 `ArrayDeque`(어레이덱)으로 구현해버릇 할 것.
### 주요 메서드
- offer() : enQueue
- poll() : deQueue
- isEmpty() : 비었나 체크
- size() : 길이(원소 개수)확인
- peek() : 
### 큐 활용 - 버퍼
