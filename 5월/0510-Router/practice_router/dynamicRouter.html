<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Vue.js SPA 예제 애플리케이션</title>    
    <script src="https://unpkg.com/vue@2"></script>
    <script src="https://unpkg.com/vue-router@3"></script>
  </head>
  <body>
    <div id="app">
      <nav>
        <!--1. router-link -->
        <router-link to="/top">최상위 페이지</router-link>
        <router-link to="/users">사용자 리스트</router-link>
      </nav>

        <!--2. router-view -->
        <router-view></router-view>
    </div>

    <!-- 사용자 목록 화면 템플릿 -->
    <template id="user-list">
      <div>      
        <div v-for="user in users" :key="user.id">
          {{user.id}}.
          <router-link :to=`/users/${user.id}`>{{ user.name }}</router-link> 
          <!-- bind를 해줘야 v-for에서 뽑아낸 user 객체임을 인지(bind안하면 그냥 텍스트로 인식) -->
        </div>
      </div>
    </template>

    <!-- 사용자 상세 정보 화면 템플릿 -->
    <template id="user-detail">
      <div>        
        <div v-if="user">
          <h2>{{ user.name }}</h2>
          <p>{{ user.description }}</p>
        </div>
      </div>
    </template>
    

    <script>    
    //로컬 스토리지 대신 저장해둔 곳    
    var userData = [
      {
        id: 1,
        name: 'Tommy Lee',
        description: '한국에서 일하는 프론트엔드 엔지니어입니다.'
      },
      {
        id: 2,
        name: 'Jane Kim',
        description: '아웃도어, 풋살이 취미인 프로그래머입니다.'
      },
      {
        id: 3,
        name: 'Harry Porter',
        description: '마법이 취미인 데이터 분석가입니다.'
      }
    ]   

 
    // 1. 사용자 목록 컴포넌트
    var UserList = {
      template: '#user-list',

      data () {
        return {        
          users: []
        }
      },

      //생성된 직후에 호출되는 메소드(life-cycle)
      //component가 가지고 있는 데이터나 메소드는 접근이 가능함.
      created() {
        this.fetchData()
      },

      //라우팅 감시//라우트 변경을 모니터링 하며 라우팅이 바뀌면 데이터를 다시 받아옴
      watch: {
        '$route': 'fetchData'
      },

      methods: {
        fetchData () {          
            this.users = userData; // 빈 배열을 채워줌
        }
      }
    }

    // 2. 사용자 상세 정보 컴포넌트
    var UserDetail = {
      template: '#user-detail',
      data() {
        return {          
          user: null,        
        }
      },

      created: function () {
        this.fetchData()
      },

      //라우트 변경을 모니터링 하며 라우팅이 바뀌면 데이터를 다시 받아옴
      watch: {         
        '$route': 'fetchData'//route 변경 시, fetchData() 메소드 호출
        //userId처럼 값만 바뀌는 경우는 route path 형식이 변경되었다고 볼 수 없기 때문에 코드로는 인지 못 함. 이럴 경우 watch를 사용
      },

      methods: {
        fetchData () {
            //1. 이전 링크에서 전달되어 온 id받기
            let id = this.$route.params.userId;
            //this.$route : 해당 컴포넌트를 호출하는 경로
            //this.$router : 해당 컴포넌트를 의미하는 객체

            //2. 전체 데이터 중에서 해당 id의 사용자 정보만 선택해서 user에 저장
            let filteredUsers = userData.filter(user => user.id == id); //.filter 메소드를 통해 하나씩 userData의 값을 하나씩 꺼냄. 반환형은 무조건 배열
            if(filteredUsers.length == 1) {
                this.user = filteredUsers[0];
            }
        }
      }
    }
   
    // 옵션을 지정해 라우터 인스턴스를 생성
    var router = new VueRouter({    // 각 라우트에 컴포넌트를 매핑
      routes: [
        {
          path: '/top',
          component: {
            template: '<div>최상위 페이지입니다.</div>'
          }
        },
        {
          path: '/users',
          component: UserList
        },        
        {
          path: '/users/:userId', //:userId : 변수로 받아질 부분, 동적으로 해결, dynamicRouter
          component: UserDetail
        },
        {          
          path: '*',// 정의되지 않은 경로 처리. 최상위 페이지로 리다이렉트
          redirect: '/top'
        }
      ]
    });
    
    // 라우터 인스턴스를 루트 Vue 인스턴스에 전달
    var app = new Vue({      
      router: router
    }).$mount('#app')
    </script>
  </body>
</html>