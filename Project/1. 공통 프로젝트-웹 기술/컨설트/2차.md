### 양방향일때, 단방향일떄 소스 조절
    화상 PT 진행 중에는 대부분이 화상 리소스 대부분을 컨트롤 할 것임.
    때문에 단방향일 경우가 많은 비중을 차지할 것이고, 이럴 경우에는 양방향일때보다 소스를 줄이는 방향으로 개선할 수 있을 것이다.

### 채팅 기능
    STOMP, RabbitMQ, Kafka 등 어떤 기술을 선택하여 사용할 지 모르겠음.
    => 우선 기능을 선택하여 만들어보자. 
    그리고 기능 선택한 이유, 해당 기능을 사용했을때 예측 결과, 결과 예측 성공 혹은 실패 여부, 결과에 대한 피드백을 남기면 베스트이다.
    이건 모든 곳에 적용 가능하다.

### 리뷰 기능
    - 리뷰 기한: PT하고나서 리뷰를 언제까지 달 수 있을 것인지

### 유저 기능
    인증 정책을 고민해야한다.

    이게 무슨 말이면,
    구글 회원가입(로그인), 카카오 회원가입(로그인)이 있다는 상황을 가정해보자.
    내가 해당 서비스를 이용하기 위해서 회원가입을 진행했고, 이를 구글을 이용해서 진행했다.
    그런데 내가 구글로 회원가입 및 로그인했던 것을 까먹었고 다시 카카오 회원가입 및 로그인을 진행했을때, 이미 구글 회원가입 및 로그인 정보가 있음을 서비스 내에서 인지하고 이를 유저에게 안내하는 것 등에 대한 정책을 고민하라는 말이다.

    이를 공부하기 위해서 필요한 키워드는 인증 키 매핑, 시퀀스, 멀티 채널 등이 있다.

### 별점 필터링
    평균 별점 저장 및 필터링은 생각보다 무거운 부분이다.
    바로 떠오르는 방법대로 한다면, 별점을 갖고있을 테이블 속성에 평균 별점과 평가자 수를 설정하고 이에 대한 카운트를 매번 해서 평균 별점을 새로 업데이트 시킬 수 있을 것이다.
    근데 이렇게하면 안하느니만 못하다고 한다.
    그 이유는 위 방법은 토이 프로젝트 스케일로만 생각하여 성능을 전혀 고려하지 않은 방법이기 때문이다.

    예를 들면, 1만 명의 서비스 이용자가 있다고 가정해보자.
    해당 서비스 이용자가 모두 PT를 받고 거기에 대한 리뷰를 단다면, 1만 명의 리뷰를 실시간으로 바로 업데이트 할 수 있겠는가? 그리고 동시 다발적으로 진행하게 되는데, 그렇다면 과연 평균 별점이 정확할까? 그리고 그 모든 조회와 업데이트를 감당할 수 있겠는가?
    이와 같이 가볍게만 생각해도 실제 서비스에서는 절대 불가능한 부분임을 알 수 있다.

    때문에 다른 방법을 고려해야하고, 이에 대한 로직과 흐름을 잘 구성하는게 포인트이므로 평균 별점 기능 및 필터링 기능은 꽤나 무거운 피쳐라고 볼 수 있다.

    - db에 직접 평균 값을 제공하지 말고 row만 기록 후 이를 다른 방법을 사용해서 평균 계산 로직을 구현하자
    - 실시간으로 계산하는 방법은 보통 리뷰의 특정 개수를 기준으로 로직을 작동시키는 것이라고 생각한다. 예를 들면, 10개의 리뷰(별점)가 제공되었을때마다 이전 평균 별점과 현재 10개를 이용하여 평균 별점을 내어 제공하는 것이다.
    - 실시간이 아닌 배치 스크립트를 사용한다면, 특정 시간을 기준으로 로직을 작동시키면 될 것 같다고 생각한다. 예를들면, 1시간을 기준을 잡고 그 기간에 해당되는 row 데이터의 별점들과 이전 평균 별점을 이용해서 로직을 구현하면 될 것 같다.
    - 그 외로 캐시를 사용하면 +1 카운트하고, 잡 스케쥴링이라는 키워드들 들었지만 명확히는 모르겠고 공부가 필요하다.

### 단골 많은 순
    어느 정도 기간내로 재 이용해야 단골로 판단해 줄 것인지, 몇 번의 재이용을 해야 단골인지 고민
    => 이는 내가 대답은 못했지만, 그냥 단골이라는 단어를 배제하고 재이용률 높은 트레이너라고 생각하면 좋을 듯 하다.

### 해결안되는 부분을 기획으로 해결할 때도 있다.
    중요하지 않은 부분, 혹은 중요하지만 기술적으로 당장은 해결이 불가능한 부분 등 우리가 구현하지 못하는 부분은 기획으로, 즉 말로 그냥 이유를 들어 해결할 때도 있어야 한다.
    하지만 말로만 하는 것은 변명일 뿐이고 이를 위해서 우리가 어떤 방법들을 고민하고 적용했는지 히스토리로 남겨놔야 한다.

### 최초 로그인
    - 클라이언트(앱)의 경우 디바이스에 심을 수 있다.

### 테이블
    내가 아는 테이블은 그냥 특정 도메인에 속하는 모든 속성을 해당 테이블에 때려박는 것만 생각할 줄 알았고, 그게 맞다고만 생각했다.
    하지만 아니다.
    그 테이블에 어떤 속성이 얼마나 접근이 많은 속성인지부터 고민해야하고, 이러한 고민을 바탕으로 테이블을 나누어야 한다.
    그렇지 않았을 때의 단적인 예를 2개 들어보겠다.
    
    첫번째 예시로 User 테이블에 user에 대한 모든 속성이 있다고 가정해보자.
    그렇다면 user의 회원가입에도 그렇겠지만, user의 프로필만 보기위해서도 user의 모든 속성이 있는 테이블에 접근해야하게 될 것이다.
    두번째 상황은 
  - feature 별로 나누는 것이 좋음. 
  - 그 예로 트래픽 문제가 걸릴 수 있음.
  - 이게 안되면 쿼리 튜닝 자체가 안 됨.

- ID
  - Long(인테져)를 사용하지말기
  - autoincrement 쓰지말기

- 태그
  - 역설계
  - RDB에 사용하는 풀 텍스트
  - user에 list혹은 구분자를 제공해서 문자열로 제공