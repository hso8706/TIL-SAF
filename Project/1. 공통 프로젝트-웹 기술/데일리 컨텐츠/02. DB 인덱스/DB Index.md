### 쿼리 튜닝
- 처음부터 리소스를 들일 부분은 아님(현업에선 필수지만)

### Index
- 테이블의 검색 속도를 향상시키기 위한 자료 구조
- full scan 방지
- 비트리, 비플러스(?)

### Index의 장점
- 성능 향상(지대한 영향을 줌, 알고리즘보다 우선 순위)
- 시스템 부하 감소

### Index의 주의점
- 관리를 위한 추가작업
  - insert : 새로운 데이터에 대한 인덱스를 추가
  - delete : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
  - update : 기존의 인덱스를 사용하지 않음 처리 및 갱신된 데이터에 대한 인덱스 추가
- 추가 저장 공간 필요
- 잘못 사용하면 성능 저하 가능성

### Index 사용 전 파악 요소
- 애플리케이션 로직내에서 해당 쿼리 및 DB 요소가 얼마나 많이 사용되는지

### Index 사용가능한 상황
- 규모가 작지 않은 테이블
- Inser, update, delete가 자주 발생하지 않는 컬럼
- join이나 where, order by에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

### Delete
- delete는 개발자가 사용하는 경우가 거의 없다.
- flag 처리로 숨길 뿐
- delete는 DBA가 사용한다.

### Update
- delete와 마찬가지로 update도 거의 안 씀
- delete는 아예 사용 안 함! update는 지양한다! 로 기억할 것

### Index 특징
- 하나 또는 여러 개의 컬럼에 설정 가능(그렇다고 보통 모든 컬럼에 적용하진 않음)
- Where 절을 사용하지 않고 조회하는 것은 성능에 영향 없음
  - 즉, 조건절을 사용하는 컬럼에 index를 잡는다고 생각하면 편함

### 단일 컬럼 Index

### 다중 컬럼 Index
- 두 개 이상의 필드를 조합해서 인덱스를 설정
- 기능과 성능이 좋지만 사용 난이도가 높고 응용력이 떨어짐

### 프로젝트 예시
- ~~기능 및 성능 개선을 위해 ~~한 인덱스를 사용하였고, 약 ~%의 성능 개선을 이뤄냈습니다.

### Index 설계 방법
- 무조건 많이 설정하지 않는다.
- 조회시 자주 사용하는 컬럼에 적용
- 고유한 값 위주로 설계
- 카디널리티가 높을 수록 좋다(= 한 컬럼이 갖고 있는 중복의 정도가 낮을 수록 좋다)
- Index 키의 크기는 되도록 작게 설계
- PK, Join의 연결고리가 되는 컬럼
- 단일 인덱스 여러 개 보다 다중 컬럼 Index 생성 고려
- Update 빈번하지 않은 컬럼
- Join시 자주 사용하는 컬럼
- Index를 생성할 때 가장 효율적인 자료형은 정수형 자료(가변적 데이터는 비효율적)

### 링크
- https://techblog.woowahan.com/2687/