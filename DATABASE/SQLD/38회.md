### 엔티티 관계
![image](https://github.com/hso8706/cos-repo/assets/103169947/2c160444-4134-4521-814d-31b9a67d9458)
    - O : 있을수도 있고, 없을수도 있다는 의미

### 성능 데이터 모델링; 성능을 고려한 데이터 모델링
    1. 정규화를 수행하여 데이터베이스 모델의 유연성을 확보한다.
    2. 데이터베이스의 전체 용량, 월간, 연간 증감율을 예측한다.
    3. 애플리케이션의 트랜잭션의 유형(CRUD)을 확인한다.
    4. 합계 및 정산 등을 수행하는 반정규화를 수행한다. (성능 향상을 위한 튜닝)
    5. 기본키와 외래키, 수퍼타입과 서브타입 등을 조정한다.
    6. 성능관점에서 데이터 모델을 검증하고 확인한다.

### 데이터 모델링 과정
![image](https://github.com/hso8706/cos-repo/assets/103169947/31826d80-a49f-4373-b703-eeffc375284f)

### 데이터 모델링 3종
- 개념적 모델링
  - ERD를 만드는 과정
  - 사용자 관점에서 데이터 요구사항을 식별함
- 논리적 모델링
  - ERD를 통해서 스키마 모델을 만드는 과정
  - M:N 관개해서, 식별자 확정, 정규화, 무결성 정의 등을 수행
- 물리적 모델링
  - 관계 스키마 모델의 물리적 구조를 정의하고 구현하는 과정
  - 데이터가 물리적으로 저장되는 방법을 정의

### 정규화의 목적
- 데이터의 정규화
  - 함수의 종속성에 따라서 테이블을 분해하는 과정
- 정규화의 목적
  - 데이터 중복 제거
  - 모델의 독립성 향상
  - 갱신 이상 방지(데이터 삽입, 삭제, 수정에 이상 현상이 있는것)

### 속성
- 기본키 속성
  - 엔티티 식별 속성(엔티티를 대표함)
  - 최소성(not null)과 유일성(중복 없음)을 만족
- 외래키 속성
  - 다른 엔티티의 관계에 포함되는 속성
  - 두 개의 테이블 간 연결을 설정하기 위한 key
- 일반 속성
  - 다른 엔티티 관계에 포함되지 않는 속성
- 파생 속성
  - 다른 특정 데이터를 기반으로 만들어진 데이터
  - 예. 가격의 평균 데이터(가격 데이터 기반으로 만듬)

### 엔티티 특징
- 식별자
  - 엔티티는 유일한 식별자가 있어야 한다.
- 인스턴스 집합
  - 엔티티는 2개 이상의 인스턴스(데이터)가 있어야 한다.
  - 예. 회원 정보는 2명 이상 있어야 한다.
- 속성
  - 엔티티는 **반드시** 속성을 가지고 있다.
- 관계
  - 엔티티는 다른 엔티티와 최소 한 개 이상의 관계가 있어야 한다.
  - 예. 회원 엔티티 => 회원 배송지 주소 엔티티, 회원 등급 엔티티 등
- 업무
  - 엔티티는 업무에서 관리되어야 하는 집합이다.
  - 예. 회원, 계좌

### IE 표기법
- 1:N 관계에서 N쪽에 새발을 표시
- 필수 참여 관계에서 선택 참여는 O, 필수 참여는  |로 표시
- 다른 표기법: Barker, IE Notation, IDEF1X

### 식별자의 특징
- 유일성
  - 주식별자에 의해 엔티티 내의 모든 인스턴스(데이터)들이 유일하게 구분되어야 한다. 
  - 데이터의 중복이 없다는 의미
- 최소성
  - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수이어야 한다.
  - 주식별자는 하나의 속성만으로 이루어져야 한다는 의미
- 불변성
  - 주식별자 값은 자주 변하지 않는 것이어야 함
- 존재성
  - 주식별자가 지정이 되면 반드시 값이 들어와야 한다.
  - NOT NULL

### 식별자 분류
![image](https://github.com/hso8706/cos-repo/assets/103169947/5b6c75b5-36cb-4524-8a92-58f1d7705f7f)

### CONNECT BY 함수
- CONNECT BY 함수
  - 해당 함수는 계층적(상하관계)으로 연결되어 있는 데이터의 관계를 출력할 때 사용한다.
  - `start with`로 시작점을 지정하고, `connect by`로 (아마도 같은 테이블 내에서)연결된 계층 관계를 이어나가며 출력한다.
- 구문 구성
  - WHERE
  - START WITH : 어떤 데이터로 계층 구조를 지정하는지
  - CONNECT BY : 각 행들의 연결 관계를 설정
- LEVEL
  - CONNECT BY 절의 결과에 생기는 컬럼명
- PRIOR
  - 현재 행과 다른 행을 구분하는 키워드
  - 해당 키워드가 붙은 값과 같은 값을 같는 모든 행을 가져온다

### <>
- 같지 않음을 의미하는 부정 연산자
- `!=`, `^=`, `NOT 컬럼명 = ` 들도 같은 의미의 연산자이다.

### DCL; Data Control Language
- GRANT: 권한 부여
- REVOKE: 권한 회수

### SQL 명령어
![image](https://github.com/hso8706/cos-repo/assets/103169947/d4e0d4f5-c534-411f-8b4b-44e8185b9d8e)

### JOIN
![image](https://github.com/hso8706/cos-repo/assets/103169947/9f9f6d48-d23c-4c57-a79b-f2c357c22d90)

### NULLIF(A, B)
- A, B 값이 같으면 NULL, 같지 않으면 첫 번쨰 값을 반환함

### COUNT 함수
- NULL 인 값을 제외하고 갯수를 카운트함
- 조건절(WHERE)이 거짓이면 0을 반환함

### 집계 함수 - ROLLUP, CUBE, GROUPING SETS
- GROUP BY와 사용되는 키워드
- ROLLUP(COL1, COL2)
  - GROUP BY로 묶은 소그룹 COL1 각각의 합계, 그리고 소그룹 전체(COL1, COL2 모두 포함)의 합계를 모두 구함
  - 출력 순서
    - 소그룹의 결과들 마지막에 해당 소그룹 합계 출력
    - 맨 마지막에 전체 합계 출력
- CUBE
  - GROUP BY로 묶은 소그룹 COL1, 그리고 COL@ 각각의 합계, 그리고 소그룹 전체(COL1, COL2 모두 포함)의 합계를 모두 구함
  - 출력 순서
    - 맨 처음에 전체 합계 출력
    - COL2에 대한 합계들 출력
    - COL1 소그룹 결과들과 해당 소그룹 결과 마지막에 합계 출력
- GROUPING SETS
  - 출력 순서
    - COL1에 대한 합계들 출력
    - COL2에 대한 합계들 출력

### 조건문 - WHEN ~ THEN ~ ELSE ~ END
- END 뒤에는 별칭을 붙일 수 있다.

### NVL 함수
- NVL(COL1, VALUE)
  - COL1이 NULL인 경우 VALUE로 치환한다.
- NVL2(COL1, VALUE1, VALUE2)
  - COL1이 NULL이 아닌 경우 VALUE1로 치환하고, NULL인 경우 VALUE2로 치환한다.

### WINDOW FUNCTION(이해 부족)
- OVER()
  - ORDER BY, GROUP BY 서브쿼리를 개선하기 위한 함수
  - 쿼리 결과 집합을 사용자 지정 정렬하는 느낌
  - OVER() 함수 내에 ORDER BY, PARTITION BY를 사용할 수 있음
- OVER 함수 구조
  ```sql
  OVER (   
      [ <PARTITION BY clause> ]  
      [ <ORDER BY clause> ]   
      [ <ROW or RANGE clause> ]  
      )  
  
  <PARTITION BY clause> ::=  
  PARTITION BY value_expression , ... [ n ]
  -- 쿼리 결과 집합을 파티션으로 분할
  
  <ORDER BY clause> ::=  
  ORDER BY order_by_expression  
      [ COLLATE collation_name ]   
      [ ASC | DESC ]   
      [ ,...n ]  
  -- 각 파티션 내에서 행의 논리적 순서 정의
    
  <ROW or RANGE clause> ::=  
  { ROWS | RANGE } <window frame extent> 
  -- 파티션의 시작점 및 끝점 지정
  ```
- UNBOUNDED PRECEDING, UNBOUNDED FOLLOWING
  - ROW or RANGE clause에 쓰이는 키워드
  - UNBOUNDED PRECEDING : 윈도우의 시작 위치가 첫번째 ROW
  - UNBOUNDED FOLLOWING : 윈도우의 마지막 위치가 마지막 ROW

### PL/SQL
- Oracle에서 사용하는 확장된 SQL 언어
- 절차형 언어
- 내부에서 테이블 생성 가능
  - 테이블 생성의 이유는 임시 테이블로 잠깐 사용하는 경우가 많음
- 조건문은 IF ~ THEN ~ ELSE IF ~ END IF와 CASE ~ WHEN을 사용한다.
- 변수에 값을 대입할 경우 ":="을 사용한다.

### 인덱스 구문
  ``` sql
  인덱스 생성 / 삭제 구문
  -- 생성
    CREATE INDEX 인덱스명
    ON 테이블명 ( 속성명 , 속성명,…)
  -- 삭제
    DROP INDEX 인덱스명
    ON 테이블명
    
  -- 수정
  인덱스 삭제 후 다시 만들어주는 방법을 사용해야 한다
  
  -- 인덱스 조회
  SELECT 테이블명, 인덱스명, 컬럼명
  FROM ALL_IND_COLUMNS
  WHERE TABLE_NAME = '테이블명'
  ```

### SAVEPOINT, ROLLBACK TO
- SAVEPOINT [세이브포인트 명] : 세이브 포인트로 저장
- ROLLBACK TO [저장된 세이브포인트 명] : 저장된 곳으로 돌아감

### DAUL 테이블
- 쿼리 결과를 담는 임시 테이블

### MINUS
- 차집합 함수
- 사용 예
  ``` sql
  SELECT * FROM TABLE1 -- 1,2,3 행이 있는 테이블
  MINUS
  SELECT 1 FROM DUAL -- 1행이 있는 임시 테이블
  -- 출력 : 2,3
  ```